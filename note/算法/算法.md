# 算法

## 回溯算法

### 概念

```
回溯算法又称回溯搜索算法,是一种搜索的方式,回溯算法本是穷举且每个回溯问题都可以抽象为树的形式

解决的问题
	组合问题:N个数里按规则找出k个数的集合
	切个问题:一个字符串按一定规则有几种切割方式
	子集问题:一个N个数的集合里有多少符合条件的子集
	排列问题:N个数按一定规则全排列,有几种排列方式
	棋盘问题:N皇后,数独等
	
注:组合不强调顺序,排列强调顺序
```

### 算法框架

```C++
void backtracking(参数){
	if(终止条件){
        存放结果;
        return;        
    }
    
    for(选择:本层集合中元素(树中节点孩子的数量集合就是集合的大小)){ //循环,横向遍历
        处理节点;
        backtracking(路径,选择列表); //递归,纵向遍历
        回溯,撤销处理结果;
    }
}
```

### 排列问题

```
两种情况:
	1、不存在重复元素:不需要对原组合进行排序,直接使用used数组标记使用过的元素即可
	2、存在重复元素:需要对原组合进行排序,因为相同元素交换位置没有意义
```

#### 不存在重复元素

```C++
//由于排列问题的特性,可将一个序列的全排列问题看作一颗树,树的根节点是这个序列本身
//根节点往下第一层的每一个节点表示以原序列某个元素为起始的新序列的各种情况
//即将原序列拆开分别选取元素为起始用序列所有元素构建新序列
//叶子节点总数即为全排列所含序列个数

void backtracking(string inser,vector<bool>& used) {
		if (temp.size() == inser.size()) {
            //到达叶子节点,保存节点信息并返回
			allstr.push_back(temp);
			return;
		}

		for (int i = 0; i < inser.size(); i++) {
			//在该树层该元素已被访问,故而跳过
			if (used[i] == true)	continue;


			//标记访问元素,加入新序列
			used[i] = true;
			temp += inser[i];
            //递归访问下一层
			backtracking(inser, used);
            //该节点情况研究完毕,临时序列删除该节点:临时序列不是清空而是删除节点
            //若清空节点则该节点d只研究了一种情况
			//temp.pop_back();
			temp.erase(temp.end()-1);
			used[i] = false;
		}
	}


	void alport(string inser) {
		temp.clear();
		allstr.clear();
		vector<bool>used(inser.size(),false);

		backtracking(inser, used);

		cout << allstr.size() << endl;
	}
```



## 动态规划

### 基本步骤

```
1.确定dp数组及下标的含义
2.确定状态转移方程
3.确定dp数组初始化方法
```

### 背包问题

#### 01背包

```
二维数组下的01背包
确定数组及下标含义
dp[i][j]:表示从下标为[0-i]的物品里任取,放进容量为j的背包,价值总和最大是多少

递推公式
	1.dp[i-1][j]:背包容量为j,里面不放物品i的最大价值
	2.dp[i-1][j-weight[i]]:dp[i-1][j-weight[i]]为背包容量为j-weight[i]时,不放物品i的最大价值,那么dp[i-1][j-weight[i]] + value[i](物品i的价值)就是背包放i得到的最大价值
	故而递推公式:dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i]);
	
dp数组初始化
	dp[i][0] = 0;//容量为0,无法放置任何物品,价值为0
	dp[0][j] = value[0];//放置0号物品时,背包容量比0号物品的重量还小,当j>=weight[0]时,背包总能放置0号物品
	故而
	for(int j = 0;j < weight[0];j++){dp[0][j] = 0;}
	for(int j = weight[0];j <= maxWeight;j++){dp[0][j] = value[0]};
	
确定遍历顺序:先物品和先重量都可以,但是先物品更好理解,之所以都可以是因为dp[i][j]是从上方和左侧推算而来故而无论先遍历谁都不影响d
```

#### 例题

**牛客华为机试 HJ16购物单**

```C++
题目:根据输入输出购买商品的最大满意度,分为主件和附件,一个主件最多两个附件,购买附件必须购买相应主件
输入的第1行,为两个正整数N，m，用一个空格隔开:
(其中N(N<32000)表示总钱数,m(m<60)为可购买的物品的个数)
从第2行到第 m+1 行,第 j 行给出了编号为 j-1 的物品的基本数据,每行有 3 个非负整数 v p q
(其中v表示该物品的价格(v<10000),p表示该物品的重要度(1 ~ 5),q表示该物品是主件还是附件.如果 q=0,表示该物品为主件,如果q>0,表示该物品为附件,q是所属主件的编号)
示例   
输入：
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
复制
输出：
2200



//dp[][]设置代码
void setdparry(vector<vector<int>>& dp, vector<TreeNode*>prolist, int value) {
    	//使用森林存储商品情况,因为主件至多有两个附件的前提下,主件与附件的关系类似一棵深度为1的二叉树
    	//当附件数为2时,就是完全二叉树,若只有一个附件,则设置为左子树
    	//使用树虽然结构清晰,但是相较数组所消耗内存
    
    
		//由于dp[][]数组的特性,从下标为1开始,一直到主件数为止,故而输入的dp数组大小为[主件数+1][总金额+1]
    	//故而商品分为主件,附件1,附件2三类
        for (int i = 1; i <= prolist.size() ; i++) {
            cout << "考虑主件" << i << "的情况，花费和重要性及满意度分别为" << prolist[i - 1]->cost << "、" << prolist[i - 1]->val << "、" << getval(prolist[i - 1]) << endl;
            for (int j = 1; j <= value; j++) {				
                //情况1:只购买一个主件的情况
                dp[i][j] = (j >= prolist[i - 1]->cost) ? max(dp[i - 1][j], (dp[i - 1][j - prolist[i - 1]->cost] + getval(prolist[i - 1]))) : dp[i - 1][j];
				//情况2:购买主件和附件1的情况
                if (prolist[i - 1]->lNode) dp[i][j] = (j >= (prolist[i - 1]->cost + prolist[i - 1]->lNode->cost)) ? max(dp[i][j], dp[i - 1][j - prolist[i - 1]->cost - prolist[i - 1]->lNode->cost] + getval(prolist[i - 1]) + getval(prolist[i - 1]->lNode)) : dp[i][j];
				//情况3:购买主件和附件2的情况
                if (prolist[i - 1]->rNode) dp[i][j] = (j >= (prolist[i - 1]->cost + prolist[i - 1]->rNode->cost)) ? max(dp[i][j], dp[i - 1][j - prolist[i - 1]->cost - prolist[i - 1]->rNode->cost] + getval(prolist[i - 1]) + getval(prolist[i - 1]->rNode)) : dp[i][j];
				//情况4:购买主件和其所有的两个附件
                if (prolist[i - 1]->lNode&& prolist[i - 1]->rNode) dp[i][j] = (j >= (prolist[i - 1]->cost + prolist[i - 1]->lNode->cost + prolist[i - 1]->rNode->cost)) ? max(dp[i][j], dp[i - 1][j - prolist[i - 1]->cost - prolist[i - 1]->lNode->cost - prolist[i - 1]->rNode->cost] + getval(prolist[i - 1]) + getval(prolist[i - 1]->lNode) + getval(prolist[i - 1]->rNode)) : dp[i][j];                             
            }
            //这里dp数组[i][j],i表示对应的主件编号,j表示花费的金额,上限为value
            //由于购买附件就必须购买主件,故而情况2\3\4中,dp[i-1][j]就不能使用了,因为只要有附件,就不存在不购买主件的情况
            //因此dp[i-1][j]所对应的就应该是dp[i][j],即只购买对应主件的情况
            //因此,以情况2为例,dp[][]状态转移方程为
            //dp[i][j] = max(dp[i][j],dp[i-1][j - prolist[i]->cost - prolist[i]->lNode->cost] + getval(prolist[i]) + getval(prolist[i]->lNode));
            //int getval(TreeNode* Node);返回购买商品的满意度
            //除了要判断满足情况时的状态转移,还有如果钱不满足购买附件及主件的情况,dp[i][j],即只买主件不买附件的情况
        }
    }
```

### 回文子串

#### 最长回文子串

#### 例题

**牛客华为机试HJ32 密码截取**

```C++
#include <iostream>
#include<vector>
#include<string>
using namespace std;

int main() {
    string instr;

    while (cin >> instr) {
        vector<vector<bool>> dp(instr.size(), vector<bool>(instr.size(), false));
        for (int n = 0; n < instr.size(); n++)    dp[n][n] = true;
        //dp[i][j]表示从str[i]到str[j]的字符串是否为回文串，即是否对称
        /*
        递推公式：dp[i][j] = (dp[i+1][j-1]&&(str[i]==str[j]))
        即若加入两个端点相等且被加入串为回文串，则端点加入后新串也为回文串
        且若被加入串为空串，则加入相同端点后新串也为回文串
        */
        int max_len = 1;
        for (int i = instr.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < instr.size(); j++) {
                //根据dp数组下标含义和递推公式，dp[i][j]依赖于dp[i+1][j-1]，故而从右上至左下
                if (instr[i] == instr[j]) {
                    //考虑两个端点是否相同
                    if (dp[i + 1][j - 1] || i + 1 >= j - 1) {
                        //考虑插入左右端点两个字符前原字符串是否为对称串
                        //同样若原串为空，插入两个相同端点后即为一个对称串
                        dp[i][j] = true;
                        max_len = max(max_len, abs(j - i) + 1);
                        //
                        //cout << "i:" << i << " j:" << j << endl;
                    }
                }
                else dp[i][j] = false;
            }
        }


        cout << max_len << endl;
    }

   
}
// 64 位输出请用 printf("%lld")
```



## 二叉树

```
创建树的结构体
	struct Treee{
		char val;
		Tree *Lchild = NULL;
		Tree *Rchild = NULL;
	}Tree,*TreeNode;
创建节点//创建单个没有任何连接的节点
	TreeNode createNode(char data){
		TreeNode newNode = (TreeNode)malloc(sizeof(Tree));
		newNode->val = data;
		newNode->Lchild = NULL;
		newNode->Rchild = NULL;
	}
连接节点生成树
	void ConnectNode(TreeNode root,TreeNode Lchild,TreeNode Rchild){
		root->Lchild = Lchild;
		root->Rchild = Rchild;
	}
```





## 查找



## 排序

### 时间对比

```
希尔排序平均时间复杂度为O(n^1.5)
冒泡排序平均时间复杂度为O(n^2)
快速排序平均时间复杂度为O(nlogn)
插入排序平均时间复杂度为O(n^2)
堆排平均时间复杂度读为O(nlogn)
归并排序平均时间复杂度为O(nlogn)

O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)
```

### 冒泡排序（Bubble Sort）

```C++
比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
针对所有的元素重复以上的步骤，除了最后一个。
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
通过两层循环控制：
第一个循环（外循环），负责把需要冒泡的那个数字排除在外；
第二个循环（内循环），负责两两比较交换。

时负:O(n^2)

void BubbleSort(int* arr,int arr_size){
    for(int i =0;i < arr_size-1;i++){
        for(int j =0;j < arr_size-1-i;j++){
            if(arr[j]<arr[j+1]){
                int temp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j+] = temp;
            }
        }
    }
}
```



### 插入排序（Insertion Sort）

```C++
类似扑克牌齐牌方式,把第一个数据当做已排好数据,之后的每一个新数据与之前已有数据比较,小则交换,否则不变

1.从第一个元素开始，该元素可以认为已经被排序
2.取出下一个元素，在已经排序的元素序列中从后向前扫描
3.如果该元素（已排序）大于新元素，将该元素移到下一位置
4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5.将新元素插入到该位置后
6.重复步骤2~5

时间复杂度:	最好情况(n)	最坏情况(n^2)
空间复杂度:	O(1)
稳定性:稳定

void InsertSort(int* arr,int arr_size) {
	for (int i = 0; i < arr_size-1; i++) {
		int end = i;
		int temp = arr[end + 1];
		while (end >= 0) {
			if (temp < arr[end]) {
				arr[end+1] = arr[end];
				end--;
			}

			else break;
		}

		arr[end + 1] = temp;
	}
}
```



### 希尔排序（Shell Sort）

```C++
可理解为分组插排
1.先取一个小于n的整数d1作为第一个增量(一般取n/2)，把文件的全部记录分成d1个组。
2.所有距离为d1的倍数的记录放在同一个组中，在各组内进行直接插入排序。
3.取第二个增量d2小于d1重复上述的分组和排序，直至所取的增量dt=1(dt小于dt-l小于…小于d2小于d1)，即所有记录放在同一组中进行直接插入排序为止

时间复杂度：

void ShellSort(int* arr, int arr_size) {
	int gap = arr_size >> 1;
	while (gap != 0) {
		for (int i = 0; i < arr_size-gap; i++) {
			int end = i;
			int temp = arr[end + gap];
			while (end >= 0) {
				if (temp < arr[end]) {
					arr[end] = arr[end + gap];
					end -= gap;
				}
				else break;
			}
			arr[end + gap] = temp;
		}
		gap >>= 1;
	}
}
```



### 选择排序（Selection Sort）

```C++
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面，或者将最大值放在最后面。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择，每一趟从前往后查找出无序区最小值，将最小值交换至无序区最前面的位置。
void SelectSort(int* arr, int arr_size){
    //标记起始元素位置
    int beg = 0;
    //标记末尾元素位置
    int end = arr_size - 1;
    
    while(beg < end){
        //标记未排序最大,最小元素位置
        int _min = beg,_max = beg;
        
        for(int i =beg+1;i <= end;i++){
            //标记目前最大/最小元素位置
            if(arr[i] < arr[_min])	_min = i;
            if(arr[i] > arr[_max])	_max = i;
        }
        //交换目前已找到最小元素位置
        swap(arr[_min],arr[beg]);
        //若该次遍历没有更大元素,则最小元素位置交换后初始标记最大元素位置已经改变
        if(_max == beg)	_max = _min;
        //交换目前已找到最大元素位置
        swap(arr[_max],arr[end]);
        
        beg++;
        end--;
    }
}
```



### 快速排序（Quick Sort）

```C++
快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

1.从数列中挑出一个元素，称为 “基准”（pivot），
2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。
递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

void QuickSort(int* arr, int arr_beg, int arr_end) {
    //若未排序数列长度不大于1,则不用排序
	if (arr_beg >= arr_end)	return;
    //标记哨兵元素和序列左右标尺
	int mid = arr_end;
	int left = arr_beg, right = arr_end - 1;
	
	while (left < right) {
        //左侧标尺找大,右侧标尺找小
		if (arr[left] < arr[mid] && left < right)	left++;
		if (arr[right] >= arr[mid] && right > left)	right--;
		
        //左右大小元素位置交换
		swap(arr[left], arr[right]);
	}
    //交换哨兵元素位置
	if (arr[left] >= arr[arr_end])	swap(arr[left], arr[arr_end]);
	else left++;
	
    //递归排序一次快排后的左右序列
	QuickSort(arr, arr_beg, left - 1);
	QuickSort(arr, left + 1, arr_end);
}
```

### 归并排序（Merge Sort）

```C++
归并排序实质是将已有序列依次划分为不同的子序列直到每个序列只有一个元素,然后再根据划分的顺序依次合并为更大的序列知道序列长度与原来序列一致

void MergeSortPort(int* arr,int arr_size){
	int *temp_arr = new int[size(arr)];
    
    if(temp_arr){
        MergeSort(arr,temp_arr,0,arr_size - 1);
        delete temp_arr;
    }
    else cout<<"faild to allocate memory!!!"<<endl;
	
}

void MergeSort(int* arr,int* temp_arr,int left,iright){
	if(left < right){
        //只有数组元素个数大于1时才需要分区
        //找中间点
        int mid = (left + right)/2;
        //递归划分左右半区
        MergeSort(arr,temp_arr,left,mid);
        MergeSort(arr,temp_arr,mid+1,right);
        //合并已划分区域
        Merge(arr,temp_arr,left,right,mid);
    }
}

//合并分区
void Merge(int* arr,int* temp_arr,int left,int right,int mid){
    //分别标记左右半区未合并元素
    int temp_l = left,temp_r = mid+1;
    //临时数组下标
    int temp = left;
    
    //合并元素
   	while (temp_l <= mid && temp_r <= right) {
		if (arr[temp_l] < arr[temp_r])	temp_arr[temp++] = arr[temp_l++];
		else	temp_arr[temp++] = arr[temp_r++];
	}
    //合并左半区剩余元素
    while(temp_l <= mid){
        temp_arr[temp++] = arr[temp_l++];
    }
    //合并右半区剩余元素
    while(temp_r <= right){
        temp_arr[temp++] = arr[temp_r++];
    }
    
    //合并数组
	while (left <= right) {
		arr[left] = temp_arr[left];
		left++;
	}
}
```



### 堆排序（Heap Sort）

```C++
利用完全二叉有序树存储序列,而用数组存储这个二叉树
顺序:建堆->排序->建堆	本质:利用大顶/小顶堆的性质找到最大/最小元素实现排序

//大顶堆或小顶堆
父节点:下标为i的元素其父节点下标为(i-1)/2
左孩子:下标为i的元素其左孩子下标为i*2+1
右孩子:下标为i的元素其右孩子下标为i*2+2

//排序算法入口
void HeapSortPort(int* arr,int arr_size){
   	
    //建堆
    for(int i = (arr_size)/2 - 1;i >= 0; i--){
        HeapCreate(arr,arr_size,i);
    }
    
    //排序
    int n = arr_size - 1;
    while(n>0){
        swap(arr[0],arr[n--]);
        for(int i = (n-1) / 2;i>=0;i--){
            HeapCreate(arr,n+1,i);
        }
    }
}
//以大顶堆为例
void HeapCreate(int* arr,int arr_size,int n){
    //arr_size为数组长度,n为对应操作元素下标
    int target = n;
    int l_son = n*2 + 1;
    int r_son = n*2	+ 2;
    
    //建大顶堆
    if(l_son < arr_size && arr[l_son] > arr[target])	target = l_son;
    if(r_son < arr_size && arr[r_son] > arr[target])	target = r_son;
    
    if(target ){
        swap(arr[target],arr[n]);
    }
    
    HeapCreate(arr,arr_size,target);
}
 
```



### 计数排序（Counting Sort） 

```
统计相同元素出现次数,根据统计的结果将序列回收到原来的序列中,计数排序只适用于范围集中且重复数据较高的数据

实现:通过STL中map容器可实现数组元素的统计
```



