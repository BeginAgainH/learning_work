# C++

## C和C++

### 特性的相同与不同

```
C++
面向对象,面向过程,泛型编程和元编程等的集合体
C++= C的超集 + 抽象机制 + 标准库
抽象机制:面向对象编程 + 模板编程

C
C语言不必指定参数类型也可以引用函数，这一点让C语言具有很强的动态特性。而C++去除了这种设计，因为破坏了类型安全。


```

```
泛型编程是一种专注于对算法及其数据结构进行设计的编程方式，它使得这些算法即数据结构能够在不损失效率的前提下，运用到最为通用的环境中。
```

```
元编程是通过程序实体操作,在编译时计算出运行程序所需要的常数,类型和代码方式.
一般的编程是通过直接编写程序，通过编译器编译，产生目标代码,并用于运行时执行.
元编程则是借助语言提供的模板机制，通过编译器推导，在编译时生成程序。元编程经过编译器推导得到的程序，再进一步通过编译器编译，产生最终的目标代码
```

### 指针

```
C
	int (*pfunc)();//pfunc可以指向任意返回值为int的函数，无论参数是什么,这是有参的情况
	int (*pfunc)(void);//无参的情况必须写明参数为void
```

### 宏定义

### C++11的特性

### 各种关键字

### 智能指针

## C++和Python

```
C++为编译语言,Python为脚本语言
编译语言需要通过编译器编译后程序才能执行,直接使用编译后的结果而不需要在执行过程中再次编译,可以脱离其语言环境独立运行,故而要修改程序就要修改其源代码,再经编译后生成新的目标文件再执行
脚本语言是解释性语言,没有编译语言那么严格的语法和规则,脚本语言不需要编译,可直接使用,通过解释器来负责解释
```



## C++和JAVA

```
Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强
Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题

```

超大数据的处理

## STL

### push_back()和emplace

```
push_back():往容器尾部添加元素,但是传入的不是元素本身,而是一个拷贝的元素

emplace():C++11特性,将相应元素作为参数传递给其构造函数,在容器中构造该元素
	emplace,emplace_back,emplace_front分别对应insert,push_back,push_f
```





# MySql



## DQL语句

#### ON和WHERE

```
on先执行,where后执行
on针对临时表生成前数据进行筛选,where是临时表生成后再对临时表数据进行过滤
如emp1 left join emp2 on...
则是以emp1为主连接emp2中符合on的数据,若emp2无符合数据,emp1中数据空缺部分用null代替(on和null在内连接时相同,左右连接不同)

on和where可以同时使用,此时where筛选的就是已经由on过滤后生成的临时表的数据,不符合条件的直接丢弃,不补
```

#### 多个子查询使用一个子查询

```
with 别名 as(select语句) select from 别名
即生成
```

#### 正则表达式



## 日期

### 日期的比较

```
datediff(datepart,startdate,enddate)
起始日期与结束日期之间的时间,datepart为两种日期的相聚类型
datepart可有
年	yy, yyyy
季度	qq, q
月	mm, m
年中的日	dy, y
日	dd, d
周	wk, ww
星期	dw, w
小时	hh
分钟	mi, n
秒	ss, s
毫秒	ms
微妙	mcs
纳秒	ns

SELECT DATEDIFF(day,'2008-12-29','2008-12-30') AS DiffDate//result:1

SELECT DATEDIFF(day,'2008-12-30','2008-12-29') AS DiffDate//result:-1
```



### 日期的格式化输出

```
选择输出的片段
DATE_FORMATE(字段名,'关键字')
	DATE_FORMAT字符串	格式化日期
	%Y-%m-%d	2017/4/30
	%e/%c/%Y %H:%i	4/7/2013 11:20
```



## 聚合函数

### SUM和COUNT

```
sum(字段名),把字段列每行中的值相加,忽略null
如果在没有返回行中使用 sum() 函数，sum 函数的返回值为 null，不是0
count(字段名),计算字段列的行数,忽略null
```



## GROUP BY

```
group by(字段名)
实际上是生成一个将原表按照字段名分组的一个虚表(临时表),即所有行按照字段名分组,故生成的虚表除字段名所在列外其他列的每一行可能有不止一个数据,故若使用select *输出的只是每组第一行的数据而导致数据丢失

执行流程
表staff有city和num两个字段
select city,count(*) from staff group by city 
创建内存临时表，表里有两个字段city和num；
全表扫描staff的记录，依次取出city = 'X'的记录。
判断临时表中是否有为 city='X'的行，没有就插入一个记录 (X,1);
如果临时表中有city='X'的行的行，就将x 这一行的num值加 1；
遍历完成后，再根据字段city做排序，得到结果集返回给客户端

临时表的排序
就是把需要排序的字段，放到sort buffer，排完就返回。排序分全字段排序和rowid排序

如果是全字段排序，需要查询返回的字段，都放入sort buffer，根据排序字段排完，直接返回
//将
如果是rowid排序，只是需要排序的字段放入sort buffer，然后多一次回表操作，再返回。
//回表操作指通过排序好的主键回到表中按主键取出所有字段值
怎么确定走的是全字段排序还是rowid 排序排序呢？由一个数据库参数控制的，max_length_for_sort_data


```



## 窗口函数

```
窗口:满足某些条件的集合,窗口函数也是在窗口范围内执行的函数
MySQL8.0及以上使用

<函数名> over (partition by <分组的列> order by <排序的列> rows between <起始行> and <终止行>)
括号即为窗口范围
<函数名>的位置，可以放以下两种函数：
1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。
2） 聚合函数，如sum. avg, count, max, min等

开窗函数的一个概念是当前行，当前行属于某个窗口，窗口由over关键字来指定函数执行的窗口范围，如果后面括号中什么都不写，则意味着窗口包含满足where条件的所有行，开窗函数基于所有行进行计算；如果不为空，则有三个参数来设置窗口，具体参数的含义如下：

partition by子句：按照指定字段进行分区，两个分区由边界分隔，开窗函数在不同的分区内分别执行，在跨越分区边界时重新初始化.
partition by 与 group by
前者不会压缩行,后者会
后者只能选取分组的列和聚合的列
即group by后生成的结果与原表的行数和列数都不同


order by子句：按照指定字段进行排序，开窗函数将按照排序后的记录顺序进行编号。可以和 partition by子句配合使用，也可以单独使用.
rows子句：当前分区的一个子集，用来定义子集的规则，通常用来作为滑动窗口使用.默认从开始到当前//BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
partition by 限定了大窗口,rows子句限定小窗口

current row 边界是当前行，一般和其他范围关键字一起使用
unbounded preceding 边界是分区中的第一行
unbounded following 边界是分区中的最后一行
expr preceding 边界是当前行减去expr的值
expr following 边界是当前行加上expr的值

因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中
开窗函数本质上也是一种普通函数，但是它和我们一般的聚合函数还是有区别的：
	聚合函数是将多条记录聚合为一条；而开窗函数是每条记录都会执行，有几条记录执行完还是几条。
	聚合函数也可以用于开窗函数中。

也是窗口函数。
1、row_number()显示分区中不重复不间断的序号
2、dense_rank()显示分区中重复不间断的序号
3、rank()显示分区中重复间断的序号
```



# 计网&网络编程

## IP地址和MAC地址

```
既然IP地址唯一定义一个主机的逻辑地址,为什么还要有MAC地址
```



## 数据类型转换问题

### <arpa/inet.h>
