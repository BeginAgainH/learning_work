# 面试题

## 浙大NGICS（面试）

### 虚函数实现的原理

```
1、虚函数就是通过虚表实现基类对于父类同名函数的重写，实现了C++的多态
2、虚表就是具有虚函数的类对象在创建时同样建立的一个逻辑上的表，其存放了指向虚函数成员的虚指针
3、虚函数的重写就是虚指针指向的重写，即子类继承父类的虚函数实质就是继承了指向虚函数的指针，又通过对指针指向的改变实现函数重写的功能
```

### 结构体和联合体

```
1、结构体成员各自拥有自己的内存空间，互不干涉，同时存在，遵循内存对齐，一个结构体对象长度为其所有成员长度之和
2、联合体成员共享一块内存空间，即共享首地址，且只有一个成员能够对其读写一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。不允许对联合体变量名U2直接赋值或其他操作
```

### 声明和定义的区别	

```
1、声明是向编译器介绍名字--标识符。它告诉编译器“这个函数或变量在某处可找到，它的模样象什么”
2、定义是说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的是函数还是变量，编译器都要为它们在定义点分配存储空间。

总之就是：把建立空间的声明成为“定义”，把不需要建立存储空间的成为“声明”
注意：基本类型变量的声明和定义(初始化)是同时产生的;而对于对象来说，声明和定义是分开的。
```



## 中科创达（笔试）

### 运算符的优先级

**（优先级值越低等级越高，同等级在前的优先级高于在后的）**	

| 优先级 | 操作符                                                       | 描述                                                         | 例子                                                         | 结合性   |
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------- |
| 1      | () [] -> . :: ++ --                                          | 调节优先级的括号操作符 数组下标访问操作符 通过指向对象的指针访问成员的操作符 通过对象本身访问成员的操作符 作用域操作符 后置自增操作符 后置自减操作符 | (a + b) / 4; array[4] = 2; ptr->age = 34; obj.age = 34; Class::age = 2; for( i = 0; i < 10; i++ ) ... for( i = 10; i > 0; i-- ) ... | 从左到右 |
| 2      | ! ~ ++ -- - + * & (type) [sizeof](http://www.cppreference.com/keywords/sizeof.html) | 逻辑取反操作符 按位取反(按位取补) 前置自增操作符 前置自减操作符 一元取负操作符 一元取正操作符 解引用操作符 取地址操作符 类型转换操作符 返回对象占用的字节数操作符 | if( !done ) ... flags = ~flags; for( i = 0; i < 10; ++i ) ... for( i = 10; i > 0; --i ) ... int i = -1; int i = +1; data = *ptr; address = &obj; int i = (int) floatNum; int size = sizeof(floatNum); | 从右到左 |
| 3      | ->* .*                                                       | 在指针上通过指向成员的指针访问成员的操作符 在对象上通过指向成员的指针访问成员的操作符 | ptr->*var = 24; obj.*var = 24;                               | 从左到右 |
| 4      | * / %                                                        | 乘法操作符 除法操作符 取余数操作符                           | int i = 2 * 4; float f = 10 / 3; int rem = 4 % 3;            | 从左到右 |
| 5      | + -                                                          | 加法操作符 减法操作符                                        | int i = 2 + 3; int i = 5 - 1;                                | 从左到右 |
| 6      | << >>                                                        | 按位左移操作符 按位右移操作符                                | int flags = 33 << 1; int flags = 33 >> 1;                    | 从左到右 |
| 7      | < <= > >=                                                    | 小于比较操作符 小于或等于比较操作符 大于比较操作符 大于或等于比较操作符 | if( i < 42 ) ... if( i <= 42 ) ... if( i > 42 ) ... if( i >= 42 ) ... | 从左到右 |
| 8      | == !=                                                        | 等于比较操作符 不等于比较操作符                              | if( i == 42 ) ... if( i != 42 ) ...                          | 从左到右 |
| 9      | &                                                            | 按位与操作符                                                 | flags = flags & 42;                                          | 从左到右 |
| 10     | ^                                                            | 按位异或操作符                                               | flags = flags ^ 42;                                          | 从左到右 |
| 11     | \|                                                           | 按位或操作符                                                 | flags = flags \| 42;                                         | 从左到右 |
| 12     | &&                                                           | 逻辑与操作符                                                 | if( conditionA && conditionB ) ...                           | 从左到右 |
| 13     | \|\|                                                         | 逻辑或操作符                                                 | if( conditionA \|\| conditionB ) ...                         | 从左到右 |
| 14     | ? :                                                          | 三元条件操作符                                               | int i = (a > b) ? a : b;                                     | 从右到左 |
| 15     | = += -= *= /= %= &= ^= \|= <<= >>=                           | 赋值操作符 复合赋值操作符(加法) 复合赋值操作符(减法) 复合赋值操作符(乘法) 复合赋值操作符(除法) 复合赋值操作符(取余) 复合赋值操作符(按位与) 复合赋值操作符(按位异或) 复合赋值操作符(按位或) 复合赋值操作符(按位左移) 复合赋值操作符(按位右移) | int a = b; a += 3; b -= 4; a *= 5; a /= 2; a %= 3; flags &= new_flags; flags ^= new_flags; flags \|= new_flags; flags <<= 2; flags >>= 2; | 从右到左 |
| 16     | ,                                                            | 逗号操作符                                                   | for( i = 0, j = 0; i < 10; i++, j++ ) ...                    | 从左到右 |

```
如何记忆两种结合性和15种优先级？下面讲述一种记忆方法。    
    结合性有两种，一种是自左至右，另一种是自右至左，大部分运算符的结合性是自左至右，只有单目运算符、三目运算符的赋值运算符的结合性自右至左。    
    优先级有15种。记忆方法如下：    
    记住一个最高的：构造类型的元素或成员以及小括号。    
    记住一个最低的：逗号运算符。    
    剩余的是一、二、三、赋值。    
    意思是单目、双目、三目和赋值运算符。    
    在诸多运算符中，又分为：    
    算术、关系、逻辑。    
    两种位操作运算符中，移位运算符在算术运算符后边，逻辑位运算符在逻辑运算符的前面。再细分如下：    
    算术运算符分     *，/，%高于+，-。    
    关系运算符中，〉，〉=，<，<=高于==，！=。    
    逻辑运算符中，除了逻辑求反（！）是单目外，逻辑与（&&）高于逻辑或（||）。    
    逻辑位运算符中，除了逻辑按位求反（~）外，按位与（&)高于按位半加（^)，高于按位或（|）。    
    这样就将15种优先级都记住了，再将记忆方法总结如下：    
    去掉一个最高的，去掉一个最低的，剩下的是一、二、三、赋值。双目运算符中，顺序为算术、关系和逻辑，移位和逻辑位插入其中。
```

### 指针

#### 数组指针和指针数组

```
数组指针和指针数组
	指针数组：形如int *p[]就叫指针数组，因为[]优先级高于*，故而int *修饰的是数组内元素，表示p[]存放的是int *类型的指针
	数组指针：形如int (*p)[]就叫指针数组，因为()优先级高于[]，故而p先与*构成指针的定义，int修饰数组内容，表示数组存放int类型				的元素，故而*p指向整个数组，指向数组的首地址
		注：数组指针和数组别名虽然都可以通过指针的形式访问数组元素，但是对于int (*p)[]和int *P = 数组名，p+1表示指针p偏移一			个数组大小的距离，即p+1 = p + 1*(sizeof([]))；而P+1表示指针指向相邻下一个数组元素，即P+1=P+1*sizeof(数组数据				类型)
	例
		int a[5]={1,2,3,4,5};
      	int b[5];
      	int *ptr=(int*)(&a+1); 
      	a是数组首地址a[0]的地址，&a是对象（数组）首地址；

		a+1是数组下一个元素的地址，即a[1];
		而&a+1是下一个对象的地址，即a[5]。
		sizeof(b) 是 数组的空间大小，即 5 * 4 = 20；
		sizeof（&b），&b是一个指向int型数据的指针，在64位系统中，指针的大小是8，所以sizeof（&b） = 8
		在C++中，数组的下标并非不可以为负数，当数组的下标为负值时，它表示的意思是从当前地址向前寻址，即为当前地址减去sizeof（类		型）的地址值。
	总结
		数组地址加n要看主体是什么:
			&A+n 加的是n个A的大小
			&A[0] + n 加的是n个A[0]的大小
			&A[0][0] + n 加的是n个A[0][0]的大小
			需要注意的是A[0]、A[0][0]在不同维度数组中代表的意义不同，例如A[0]：
            在一维数组中代表第一个元素，即一个数值
            在二位数组中代表第一个元素，即一个一维数组，即一个地址，需要再加*取值
         解析：指针做偏移操作的时候是根据指针的类型来做出移位判断，比如这个例子里面&A相当于*p = &A，p是指向数组A的数组指针类				型，所以每次偏移的时候是按照数组的长度偏移；&A[0]相当于*p = &(A[0])，p是指向数组A的第0个元素的指针类型，所					以每次偏移的时候是按照该元素类型的长度偏移。

```

#### 函数指针

```
定义方式：data_types (*func_pointer)( data_types arg1, data_types arg2, ...,data_types argn);
例子：int (*fp)(int a); // 表示一个int一个指向函数(这个函数参数仅仅为一个int类型，函数返回值是int类型)的指针 fp
						//a可以不写只有int
						
函数指针同样可以作为参数传递给另一个函数
	int test2(int (*fun)(int),int b)
        {

            int c = fun(10)+b;
            return c;
        }
 

```

##### 指向类成员函数的指针

```
定义：用于存储一个指定类具有给定的形参列表于返回值类型的成员函数的访问信息
	1、函数指针赋值用&
	2、使用 .* (实例对象)或者 ->*（实例对象指针）调用类成员函数指针所指向的函数
例子
	A a;
    B b;
    void (A::*ptr)(int) = &A::setA;	//创建一个类成员函数指针
    								//指针定义：函数返回值类型 (类名::*指针名)(函数形参列表) = &类名::函数名
    A* pa = &a;
    
    (pa->*ptr)(1000);
    (a.*ptr)(10000);
```

### 标识符命名的合法规则

```
1、第一个字符必须是字母（不分大小写）或下划线（_）;
2、后跟字母（不分大小写）、下划线（_）或数字组成;
3、标识符中的大小写字母有区别；
4、不能与c编译系统已经预定义的、具有特殊用途的保留标识符（即关键字）同名。比如，不能将标识符命名为float,auto,break,case,
	this,try,for,while,int,char,short, unsigned,等等；
```

C++基本概念

## 同花顺(笔试)

### 正则表达式

**概念:	**正则表达式是一种用于匹配字符串的工具，可以在文本中查找特定的模式，并且可以快速地对字符串进行搜索和处理

**语法** 

​	字符：普通字符表示自身匹配，例如匹配字母a就是一个普通字符a

​	字符组：字符组用[]表示，可以匹配其中任意字符。

​	量词：量词表示匹配字数，例如匹配一个数字可以用量词 \d 表示，其中 \d 表示匹配一个数字字符，+ 表示匹配一次或多次

​	边界：边界用于限制匹配范围，例如匹配以数字开头的字符串可以使用边界 ^ 表示，表示匹配以开头的字符

​	特殊字符：一些特殊字符用于表示空格、换行、制表符等不可见字符。例如表示换行符的字符是 \n

```
符号	意义						符号	意义
^	匹配行的开头				    \	转义字符
$	匹配行的结尾					\d	匹配数字[0-9]
.	匹配任意单个字符			   \D  \d 取反
[…]	匹配[]中的任意一个字符		  \w  匹配字母[a-z]，数字，下划线
(…)	设定分组					  \W  \w 取反
    
?	前面的元素重复0次或1次		  \s	匹配空格					  
	前面的元素重复n次			 	\S	\s 取反	
	前面的元素重复至少n次			   +	前面的元素重复1次或多次
	前面的元素重复至少n次，至多m次    *	前面的元素重复任意次
	
|	逻辑或
```

**表达式操作**

​	**std::regex**	是C++用来表示「正则表达式」（regular expression）的库，于C++11加入，它是class std::basic_regex<>针对char类型的一个特化，还有一个针对wchar_t类型的特化为std::wregex

​	**std::regex_match**	用于对一个字符串进行匹配，判断字符串是否符合指定的正则表达式

```
语法	bool std::regex_match(const std::string& str, const std::regex& re);
其中 str 表示待匹配的字符串，re 表示正则表达式；函数返回一个布尔值，表示匹配结果

示例
//判断字符串 s 是否是一个数字
#include <regex>
#include <iostream>
using namespace std;

int main() {
    string s = "123";
    regex re("\\d+");
    if (regex_match(s, re)) {
        cout << "Match!" << endl;
    } else {
        cout << "Not match!" << endl;
    }
    return 0;
}
```

​	**std::regex_replace**	用于对一个字符串进行替换，将符合指定正则表达式的部分替换为指定的字符串

```
语法	std::string std::regex_replace(const std::string& str, const std::regex& re, const std::string& replacement);
其中 str 表示待替换的字符串，re 表示正则表达式，replacement 表示替换字符串；函数返回一个新的字符串，表示替换后的结果

示例
//将字符串中的数字替换为 ***
#include <regex>
#include <iostream>
using namespace std;

int main() {
    string s = "123 abc 456 def";
    regex re("\\d+");
    string result = regex_replace(s, re, "***");
    cout << result << endl;  // 输出 "*** abc *** def"
    return 0;
}

```

​	**std::regex_search**	用于在一个字符串中搜索符合指定正则表达式的子字符串

```
语法	bool std::regex_search(const std::string& str, const std::regex& re);
str 表示待搜索的字符串，re 表示正则表达式；函数返回一个布尔值，表示搜索结果

示例
//搜索字符串 s 中是否包含数字
#include <regex>
#include <iostream>
using namespace std;

int main() {
    string s = "123 abc";
    regex re("\\d+");
    if (regex_search(s, re)) {
        cout << "Match!" << endl;
    } else {
        cout << "Not match!" << endl;
    }
    return 0;
}

```

最长居住时间问题：有N元M瓶水，超市一瓶水可卖1元，每天房租X元，喝Y瓶水

linux中core信息的使用

### 宏定义和运算符优先级（#define mul(x,y)  ++x*y ++

**宏定义的本质**	文本替换

从发送信息到显示消息未读，数据的传递过程

### 模板类实现pow

**原理**	通过模板的递归实现pow

**注意事项**	模板类的参数需传入常量，且需要定义一个特例化模板让编译器知道何时能结束，因为对于模板递归是无限的

**详情见C++(进阶)**

## 同花顺（面试）

**链表移位**

**STL数据结构（包括存储结构）**

**linux常用命令**

**mysql命令**

## 工行杭州软院（大数据）

**linux指令**

