# 多进程

## 基本概念

进程：每执行一个程序系统就会启动一个进程，进程概念是针对系统而言

linux中的进程：有三部分，代码段、堆栈段、数据段

​	代码段：存放程序代码

​	堆栈段：存放程序的返回地址，参数和局部变量

​	数据段：存放程序全局变量、常熟及动态分配的数据空间

​	若系统运行多个相同程序，其代码段相同，堆栈和数据段不同



linux查看进程指令

```
ps	查看当前终端所有进程
	ps -ef 查看系统全部的进程		ps-ef|more 查看系统全部的进程，结果分页显示
	显示参数
		UID 启动进程的操作系统用户    PID 进程编号    PPID 进程的父进程的编号    C CPU使用的资源百分比
		STIME 进程启动时间    TTY 进程所属终端    TIME 使用掉的CPU时间    CMD 执行的命令
	ps -ef|grep book 查看系统全部的进程，然后从结果集中过滤出包含“book”单词的记录
	
```



获取进程编号

```
getpid()库函数
pid_t getpid();//函数没有参数，返回进程编号，pid_t就是typedef int pid_t 
pid_t getppid();//fa
```



## 系统实现多进程

### fork()

​	**概念**：进程运行时使用fork()，就产生了另一个进程，于是进程就分叉了

​	**函数声明**：pid_t fork();	fork()产生一个新进程

​	**返回值**	pid_t，在父进程中返回值是子进程编号，在子进程中返回值为0



​	**执行fork()后发生了什么？** 

​		1、fork()函数创建了一个新的进程，该进程和原进程为父子，子进程使用父进程相同代码段并拷贝了父进程的堆栈段和数据段

​		2、子进程一旦开始运行，就会复制父进程一切数据然后各自运行，相互间没有影响

​		3、子进程复制父进程代码后，从fork()开始往下执行，fork()之前的不执行

### exec()

​	**概念**：fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一				个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用				exec并不创建新进程，所以调用exec前后该进程的id并未改变

```c++
int execl(const char *path, const char *arg, ...);
	/*
		l(list)命令行参数列表
		成功无返回，失败返回-1
		对比execlp，如加载"ls"命令带有-l，-F参数
      	execlp("ls", "ls", "-l", "-F", NULL);  使用程序名在PATH中搜索。
      	execl("/bin/ls", "ls", "-l", "-F", NULL);    使用参数1给出的绝对路径搜索。
	*/
int execlp(const char *file, const char *arg, ...);
	/*
		l(list)命令行参数列表，p(path)搜索file时使用path变量
		成功无返回，失败返回-1
		参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。
      	该函数通常用来调用系统程序。如：ls、date、cp、cat等命令
	*/

注意：exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用
			perror()和exit()，无需if判断
```

### 子进程的回收和僵尸进程

#### 子进程的回收

##### wait()

​	**概念**：一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如				果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或				waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是				它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程

​	**功能**：1、阻塞等待子进程退出（父进程进行回收，执行后若子进程没有死，会一直等待子进程结束后回收资源）

​				2、回收子进程残留资源

​				3、获取子进程结束状态（退出原因）

​	**函数原型**：`pid_t wait(int *status);`	//成功返回清理掉的子进程ID，失败返回-1（或是没有子进程）

​	**当进程终止时，操作系统的隐式回收机制会**：

​		1.关闭所有文件描述符 

​		2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号)

```
	status为wait()的传出参数，通过int变量接收，通过宏函数进一步判断进程终止原因		
		1、WIFEXITED(status) 为非0    →进程正常结束
				WEXITSTATUS(status) 如上宏为真，使用此宏→获取进程退出状态 (exit的参数)

		2、WIFSIGNALED(status) 为非0 →进程异常终止
				WTERMSIG(status) 如上宏为真，使用此宏→取得使进程终止的那个信号的编号。

		3、WIFSTOPPED(status) 为非0 →进程处于暂停状态
				WSTOPSIG(status) 如上宏为真，使用此宏→取得使进程暂停的那个信号的编号。
				WIFCONTINUED(status) 为真→进程暂停后已经继续运行
				
```

​	

​	**示例**

```
		//wpid = wait(NULL);	//传出参数
		wpid = wait(&status);	//传出参数

		if(WIFEXITED(status)){	//正常退出
			printf("I'm parent, The child process "
					"%d exit normally\n", wpid);
			printf("return value:%d\n", WEXITSTATUS(status));

		} else if (WIFSIGNALED(status)) {	//异常退出
			printf("The child process exit abnormally, "
					"killed by signal %d\n", WTERMSIG(status));
										//获取信号编号
		} else {
			printf("other...\n");
		}
```



##### waitpid()

```
头文件：<sys/types.h> <sys/wait.h>
函数原型：pid_t waitpid(pid_t pid,int *status,int options);
	参数解析
        pid
            pid=-1,等待任意一个子进程，和wait等效
            pid>0:只等待进程id等于pid的进程
            pid=0:等待同一进程组的任意一个进程，如果子进程加入其他进程组不加理会
            pid<-1时，等待一个指定进程组中的任意一个进程，这个进程组的id就是pid的绝对值

        status	保存子进程的状态，有了这个信息父进程就可以了解子进程为何退出，正常退出还是一场，为传出参数
        	这里status是自定义的整形，通过这个整形获取子进程状态
        	信息解析函数
                WIFEXITED(status) 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）
                WEXITSTATUS(status) 若WIFEXITED 非零，提取子进程退出码（查看进程退出码）
                WIFISIGNALED(status) 若子进程因为一个未捕获的信号而终止，返回真，否则假
                WTERMSIG(status) 若真，则可用该宏获得导致子进程终止的信号代码

        options
            参数为0:也就是阻塞版本的等待，也就是说该waitpid在子进程没有退出情况下就不会返回，就和wait的使用一模一样，因为						wait的使用就是阻塞版本的等待方式
            参数为WNOHANG:若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回孩子进程的进程id
                而设置这个参数：返回情况有以下几种：
                    若pid指定的子进程没有结束，则waitpid()函数返回0，父进程不予以等待；
                    若正常结束，则返回该子进程的ID；
                    若等待失败，即返回小于0；
	返回值：
		1、正常返回，返回收集到的子进程ID
		2、设置WNOHANG，调用中pid发现没有已退出的子进程可收集，返回0
		3、若调用中出错，返回-1，此时errno设置为相应的值以示指示错误所在
```



##### wait()和waitpid()

**注意**：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环，而wait回收的是最早死亡的子进程，waitpid()回收目			标子进程

```
1、对于 waitpid 函数就是wait函数的增强版；
		waitpid 函数 的使用方式 waitpid(-1,NULL,0) 等价 wait 函数的使用 wait(NULL) 两者这样使用一样的
2、对于status参数，其实是一个输出型参数，也就是父进程调用该waitpid时候，可以传入一个 地址给 status；待该waitpid执行结束返		回时候，会得到该staus的值
3、status的值表示子进程的退出码的信息，也就是父进程为了得到子进程的退出信息，就是可以通过设置一个参数传入给status,获得子		进程的信息，也可以设置为NULL即不接收
4、status的退出信息：也就是子进程退出的信息，而进程退出只有三种状态：正常退出执行代码结果正确，异常退出，正常退出了但是		执行的结果不正确；异常退出的进程：本质是因为收到了某种信号，才会异常退出，而对于正常退出的进程，才有退出码而言说法；		不管是信号还是退出码，都是子进程需要返回给父进程中stauts参数的
5、其次这个 stauts，父进程获得子进程的status；不可以简简单单的认为 stauts就是一个整形int,我们要把它为一个位图；对于32位的		int类型来说：我们status是在每一个位上设置它的信息来使用的；高16位不使用，而低16位使用来表示具体信息
```

![image-20230922232049263](C:\Users\BeginAgain\AppData\Roaming\Typora\typora-user-images\image-20230922232049263.png)

#### 僵尸进程和孤儿进程

**孤儿进程**	父进程先于子进程结束，则子进程成为孤儿进程，子进程的父进程变为init进程，称为init进程领养孤儿进程

**僵尸进程**	进程终止但父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程。

​					理论上所有子进程都会经历僵尸进程

#### 信号和子进程回收

**SIGCHLD**

**概念**	子进程状态改变或结束时会像父进程发送SIGCHLD信号，父进程通过对SIGCHLD信号的捕捉和操作实现对子进程的回收

**问题**

​	**1、为什么要提前屏蔽SIGCHLD信号**

​		进程在处理信号时首先需注册信号，即通过sigaction注册信号函数的捕捉后才能对响应信号进行捕捉和函数操作。SIGCHLD默认处		理为忽略，而子进程不一定在父进程注册信号函数的捕捉后结束并发送SIGCHLD信号，故而在父进程完成对信号函数的注册前先屏蔽		SIGCHLD信号，使得于注册前结束的子进程发送的SIGCHLD阻塞，保持未决状态等待父进程注册信号捕捉函数后再解除对信号的阻		塞从而保证所有子进程结束产生的SIGCHLD都能被捕捉

​	**2、为什么循环执行waitpid()**

​		多个子进程可能同时结束并发送SIGCHLD，而每次waitpid()只能处理一个子进程，因此通过while(waitpid(-1,&status,0) != -1)或		    		while(wait(NULL) != -1)实现对于所有结束子进程的回收

