# 多进程

## 基本概念

进程：每执行一个程序系统就会启动一个进程，进程概念是针对系统而言

linux中的进程：有三部分，代码段、堆栈段、数据段

​	代码段：存放程序代码

​	堆栈段：存放程序的返回地址，参数和局部变量

​	数据段：存放程序全局变量、常熟及动态分配的数据空间

​	若系统运行多个相同程序，其代码段相同，堆栈和数据段不同



linux查看进程指令

```
ps	查看当前终端所有进程
	ps -ef 查看系统全部的进程		ps-ef|more 查看系统全部的进程，结果分页显示
	显示参数
		UID 启动进程的操作系统用户    PID 进程编号    PPID 进程的父进程的编号    C CPU使用的资源百分比
		STIME 进程启动时间    TTY 进程所属终端    TIME 使用掉的CPU时间    CMD 执行的命令
	ps -ef|grep book 查看系统全部的进程，然后从结果集中过滤出包含“book”单词的记录
	
```



获取进程编号

```
getpid()库函数
pid_t getpid();//函数没有参数，返回进程编号，pid_t就是typedef int pid_t 
pid_t getppid();//fa
```



## 系统实现多进程

### fork()

概念：进程运行时使用fork()，就产生了另一个进程，于是进程就分叉了

函数声明：pid_t fork();	fork()产生一个新进程，返回值为pid_t，在父进程中返回值是子进程编号，在子进程中返回值为0



执行fork()后发生了什么？ 

1、fork()函数创建了一个新的进程，该进程和原进程为父子，子进程使用父进程相同代码段并拷贝了父进程的堆栈段和数据段

2、子进程一旦开始运行，就会复制父进程一切数据然后各自运行，相互间没有影响

3、子进程复制父进程代码后，从fork()开始往下执行，fork()之前的不执行

### exec()

概念：fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个			程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec			并不创建新进程，所以调用exec前后该进程的id并未改变

```c++
int execl(const char *path, const char *arg, ...);
	/*
		l(list)命令行参数列表
		成功无返回，失败返回-1
		对比execlp，如加载"ls"命令带有-l，-F参数
      	execlp("ls", "ls", "-l", "-F", NULL);  使用程序名在PATH中搜索。
      	execl("/bin/ls", "ls", "-l", "-F", NULL);    使用参数1给出的绝对路径搜索。
	*/
int execlp(const char *file, const char *arg, ...);
	/*
		l(list)命令行参数列表，p(path)搜索file时使用path变量
		成功无返回，失败返回-1
		参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。
      	该函数通常用来调用系统程序。如：ls、date、cp、cat等命令
	*/

注意：exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1。所以通常我们直接在exec函数调用后直接调用
			perror()和exit()，无需if判断
```

### 子进程的回收和僵尸进程

#### 子进程的回收

##### wait()

​	概念：一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如				果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或				waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是				它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程

​	功能：1、阻塞等待子进程退出（父进程进行回收，执行后若子进程没有死，会一直等待子进程结束后回收资源）

​				2、回收子进程残留资源

​				3、获取子进程结束状态（退出原因）

​	函数原型：pid_t wait(int *status);	//成功返回清理掉的子进程ID，失败返回-1（或是没有子进程）

​	当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进
​	程的退出状态。(正常终止→退出值；异常终止→终止信号)

```
	status为wait()的传出参数，通过int变量接收，通过宏函数进一步判断进程终止原因		

		1、WIFEXITED(status) 为非0    →进程正常结束
				WEXITSTATUS(status) 如上宏为真，使用此宏→获取进程退出状态 (exit的参数)

		2、WIFSIGNALED(status) 为非0 →进程异常终止
				WTERMSIG(status) 如上宏为真，使用此宏→取得使进程终止的那个信号的编号。

		3、WIFSTOPPED(status) 为非0 →进程处于暂停状态
				WSTOPSIG(status) 如上宏为真，使用此宏→取得使进程暂停的那个信号的编号。
				WIFCONTINUED(status) 为真→进程暂停后已经继续运行
```

```C++
		//wpid = wait(NULL);	//传出参数
		wpid = wait(&status);	//传出参数
 
		if(WIFEXITED(status)){	//正常退出
			printf("I'm parent, The child process "
					"%d exit normally\n", wpid);
			printf("return value:%d\n", WEXITSTATUS(status));
 
		} else if (WIFSIGNALED(status)) {	//异常退出
			printf("The child process exit abnormally, "
					"killed by signal %d\n", WTERMSIG(status));
										//获取信号编号
		} else {
			printf("other...\n");
		}
```



##### waitpid()

​	作用：回收已经退出的子进程的资源，获取子进程的退出信息，防止出现僵尸进程

​	函数原型：pid_t waitpid(pid_t pid,int *status,int options);//

```
pid
	pid=-1,等待任意一个子进程，和wait等效
	pid>0:只等待进程id等于pid的进程
	pid=0:等待同一进程组的任意一个进程，如果子进程加入其他进程组不加理会
	pid<-1时，等待一个指定进程组中的任意一个进程，这个进程组的id就是pid的绝对值

status
	WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）
	WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）

options
	参数为0:也就是阻塞版本的等待，也就是说该waitpid在子进程没有退出情况下就不会返回，就和wait的使用一模一样，因为wait的使用就是阻塞版本的等待方式
	参数为WNOHANG:若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回孩子进程的进程id
	而设置这个参数：返回情况有以下几种：
		若pid指定的子进程没有结束，则waitpid()函数返回0，父进程不予以等待；
		若正常结束，则返回该子进程的ID；
		若等待失败，即返回小于0；
```



##### wait()和waitpid()

注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环，而wait回收的是最早死亡的子进程，waitpid()回收目			标子进程

1、对于 waitpid 函数就是 wait函数的增强版；
		waitpid 函数 的使用方式 waitpid(-1,NULL,0) 等价 wait 函数的使用 wait(NULL) 两者这样使用一样的
2、对于status参数，其实是一个输出型参数，也就是父进程调用该waitpid时候，可以传入一个 地址给 status；待该waitpid执行结束返		回时候，会得到该staus的值
3、status的值表示子进程的退出码的信息，也就是父进程为了得到子进程的退出信息，就是可以通过设置一个参数传入给status,获得子		进程的信息
4、status的退出信息：也就是子进程退出的信息，而进程退出只有三种状态：正常退出执行代码结果正确，异常退出，正常退出了但是		执行的结果不正确；异常退出的进程：本质是因为收到了某种信号，才会异常退出，而对于正常退出的进程，才有退出码而言说法；		不管是信号还是退出码，都是子进程需要返回给父进程中stauts参数的
5、其次这个 stauts，父进程获得子进程的status；不可以简简单单的认为 stauts就是一个整形int,我们要把它为一个位图；对于32位的		int类型来说：我们status是在每一个位上设置它的信息来使用的；高16位不使用，而低16位使用来表示具体信息

![image-20230922232049263](C:\Users\BeginAgain\AppData\Roaming\Typora\typora-user-images\image-20230922232049263.png)

#### 僵尸进程和孤儿进程

产生原因：因为父进程无法预知子进程什么时候结束，故而会有父进程先于子进程结束而没法回收子进程的情况，此时子进程就变为孤儿					进程，孤儿进程由init进程完成收集工作；而如果子进程先于父进程结束，同时父进程太忙而无法回收子进程资源，子进程残					留资源存放于内核中，变成了僵尸进程



